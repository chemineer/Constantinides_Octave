function [x,y] = collocation(ODEfile,x0,xf,y0,yf,guess,n,rho,tol,varargin)%COLLOCATION Solves a boundary value set of ordinary differential% equations by the orthogonal collocation method.%%   [X,Y]=COLLOCATION('F',X0,XF,Y0,YF,GAMMA,N) integrates the set of%   ordinary differential equations from X0 to XF by the Nth-degree%   orthogonal collocation method.  The equations are contained in%   the M-file F.M.  Y0, YF, and GAMMA are the vectors of initial%   conditions, final conditions, and starting guesses respectively.%   The function returns the independent variable in the vector X%   and the set of dependent variables in the matrix Y.%	%   [X,Y]=COLLOCATION('F',X0,XF,Y0,YF,GAMMA,N,RHO,TOL,P1,P2,...)%   uses relaxation factor RHO and tolerance TOL for convergence%   test.  Additional parameters P1, P2, ... are passed directly to%   the function F.  Pass an empty matrix for RHO or TOL to use the%   default value.%%   See also SHOOTING% (c) N. Mostoufi & A. Constantinides% January 1, 1999% Initializationif nargin < 7 | isempty(n)   n = 1;endif nargin < 8 | isempty(rho)   rho = 1;endif nargin < 9 | isempty(tol)   tol = 1e-6;endy0 = (y0(:).')';			% Make sure it's a column vectoryf = (yf(:).')';			% Make sure it's a column vectorguess = (guess(:).');	% Make sure it's a column vector% Checking the number of guessesif length(yf) ~= length(guess)   error(' The number of guessed conditions is not equal to the number of final conditions.')endr = length(y0);			% Number of initial conditionsm = r + length(yf);		% Number of boundary conditions% Checking the number of equationsftest = feval(ODEfile,x0,[y0 ; guess],varargin{:});if length(ftest) ~= m   error(' The number of equations is not equal to the number of boundary conditions.')endfprintf('\n Integrating. Please wait.\n\n')% Coefficients of the Legendre polynomialfor k = 0 : n/2   cl(2*k+1) = (-1)^k * gamma(2*n-2*k+1) / ...      (2^n * gamma(k+1) * gamma(n-k+1) * gamma(n-2*k+1));   if k < n/2      cl(2*k+2) = 0;   endendzl = roots(cl);				% Roots of the Legendre polynomialz = [-1; sort(zl); 1];		% Collocation points (z)x = (xf-x0)*z/2+(xf+x0)/2;	% Collocation points (x)% Bulding the vector of starting values of the dependent variables[p,q] = RK(ODEfile,x0,xf,(xf-x0)/20,[y0 ; guess],2,varargin{:});for k = 1:m   y(k,:) = spline(p,q(k,:),x');endy(r+1:m,end) = yf(1:m-r);% Building the matrix AQ(:,1) = ones(n+2,1);C(:,1) = zeros(n+2,1);for i = 1:n+1   Q(:,i+1) = x.^i;   C(:,i+1) = i*x.^(i-1);endA = C*inv(Q);for k = 1:m   k1 = (k-1)*(n+2)+1;   k2 = k1 + n+1;   Am(k1:k2,k1:k2) = A;		% Building the matrix Am   Y(k1:k2) = y(k,:);		% Building the vector YendY = Y';							% Make it a column vectorY1 = Y * 1.1;iter = 0;maxiter = 100;F = zeros(m*(n+2),1);Fa = zeros(m*(n+2),1);dY = zeros(m*(n+2),1);position = [];	% Collocation points excluding boundary conditionsfor k = 1:m   if k <= r      position = [position, (k-1)*(n+2)+[2:n+2] ];   else      position = [position, (k-1)*(n+2)+[1:n+1] ];   endend% Newton's methodwhile max(abs(Y1 - Y)) > tol & iter < maxiter   iter = iter + 1;   fprintf(' Iteration %3d\n',iter)   Y1 = Y;   % Building the vector F   for k = 1:n+2      F(k : n+2 : (m-1)*(n+2)+k) = ...         feval(ODEfile,x(k),Y(k : n+2 : (m-1)*(n+2)+k),varargin{:});   end   fnk = Am * Y - F;         % Set dY for derivation   for k = 1:m*(n+1)      if Y(position(k)) ~= 0         dY(position(k)) = Y(position(k)) / 100;      else         dY(position(k)) = 0.01;      end   end      % Calculation of the Jacobian matrix   for k = 1:m      for kk = 1:n+1         a = Y;         nc = (k-1)*(n+1)+kk;         a(position(nc)) = Y(position(nc)) + dY(position(nc));         for kkk = 1:n+2            Fa(kkk : n+2 : (m-1)*(n+2)+kkk) = ...              feval(ODEfile,x(kkk),a(kkk:n+2:(m-1)*(n+2)+kkk),varargin{:});         end         fnka = Am * a - Fa;         jacob(:,nc) = (fnka(position) - fnk(position))...            / dY(position(nc));      end   end   % Next approximation of the roots   if det(jacob) == 0      Y(position) = Y(position) + max([abs(dY(position)), 1.1*tol]);   else      Y(position) = Y(position) - rho * inv(jacob) * fnk(position);   endend% Rearranging the y'sfor k = 1:m   k1 = (k-1)*(n+2)+1;   k2 = k1 + n+1;   y(k,:) = Y(k1:k2)';endx = x';if iter >= maxiter   disp('Warning : Maximum iterations reached.')end