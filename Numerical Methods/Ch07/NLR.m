function [b, yc, w, A] = NLR(b0, n, x, y, fnctn, ODEfile, x0, y0, ...   method, tol, trace, varargin)%NLR Least squares multiple nonlinear regression.%% NLR(B0,N,X,Y,'F') returns the vector of parameters B to best fit% the nonlinear function F(X,B) to the data Y.% B0 is the vector of initial guess of parameters.% N is the vector of number of observations of each dependent% variable.% Y can be either a column vector (single regression) or a matrix% (multiple regresion) whose columns are the observed dependent% variables. Each column represents a different dependent variable.% X is the vector/matrix of independent variables correponding to% the elements of Y.% The M-file F.M returns a vector of objective function values:% Ycalc = F(X,B).%% NLR(B0,N,X,Y,'F','DF',X0,Y0) considers the objective functions to% be both algebraic [given in the M-file F.M as F(X,B)] and as ordinary% differential equations [given in the M-file DF.M as DF(X,Y,FLAG,B)% where FLAG is a dummy variable which would not be used in DF]. X0 is% the values of the independent variable and Y0 is the vector of values% of the dependent variable at boundary condition. Pass an empty matrix% as the sixth input argument if the problem on hand does not contain% any algebraic equations.%% NLR(B0,N,X,Y,'F','DF',X0,Y0,METHOD,TOL,TRACE) applies the method of% solution METHOD for finding the least sum of squares. The default% algorithm is the Marquardt method (METHOD=1). Other algorithm is the% Gauss-Newton (METHOD=2).% TOL is a vector with the maximum length of three and contains% convergence criterions. If TOL is a scalar, it will be considered% as the convergence criterion for the parameters only. If TOL is a% vector of two or three elements, its elements are considered as% convergence criterions for parameters, weights, and sum of squared% residuals, respectively.% A non-zero value for TRACE makes the function display the result of% calculations at the end of each iteration. Pass empty matrices as% the seventh and eighth input arguments if the problem on hand does% not contain any differential equations.%% NLR(B0,...,TRACE,P1,P2,...) passes the extra parameters P1, P2, ...% directly to the functions F.M and DF.M as F(X,B,P1,P2,...) and% DF(X,Y,[],B,P1,P2,...). pass empty matrices for METHOD, TOL, and% TRACE to use the default values.%% [B,YC,W,A]=NLR(B0,...) returns the fitted parameters B as well as% the calculated values of the dependent variable(s) YC, the weighting% factors W, and the matrix A=sum{wj*jabobian'*jacobian).%% See also CURVEFIT% by N. Mostoufi & A. Constantinides% January 1, 1999% Initializationk = length(b0);                      % Number of parametersb0 = (b0(:).')';                     % Make sure it's a column vectorv = length(n);                       % Number of dependent variablesif size(x) ~= size(y)   error('x and y are not of the same size.')   %breakendsy = size(y);if sy(2) ~= v   error('Invalid number of dependent variables.')   %breakend% Determining number of algebraic equationsif isempty(fnctn)   p = 0;else   ftest = feval(fnctn,x(1,1),b0,varargin{:});   p = length(ftest);end% Determining number of differential equationsif nargin == 5 | isempty(ODEfile)   q = 0;else   ftest = feval(ODEfile,x0,y0,[],b0,varargin{:});   q = length(ftest);end% Check the boundary conditionsif q > 0   ny0 = length(y0);   if ny0 ~= v      error('Invalid number of boundary condition(s).')      %break   endend% Check number of equationsif p+q ~= v   error('Number of equations is not equal to number of variables.')   %breakendif nargin < 8 | isempty(method)   method = 1;                          % The Marquardt method (default)endif nargin < 9 | isempty(tol)   tolb = 1e-3;   tolw = 1e-3;   tolphi = 1e-6;else   switch length(tol)   case 1      tolb = tol;      tolw = 1e-3;      tolphi = 1e-6;   case 2      tolb = tol(1);      tolw = tol(2);      tolphi = 1e-6;   case 3      tolb = tol(1);      tolw = tol(2);      tolphi = tol(3);   endendif nargin < 10 | isempty(trace)   trace = 0;endheaderw = ' Variable   Weight';headerb = ' Parameter   Value';% Calculating the weightsv = length(n);                       % Number of dependent variablesif v > 1   for nv = 1:v      % Sorting data      [xx(1:n(nv),nv),loc] = sort(x(1:n(nv),nv));      yy(1:n(nv),nv) = y(loc,nv);      tmpy = yy(1,nv);         ss(nv) = 0;      ns(nv) = 0;      % Search for repeated data      for nn = 2:n(nv)         if xx(nn-1,nv) == xx(nn,nv)            tmpy = [tmpy; yy(nn,nv)];         else               if length(tmpy) ~= 1               ly = length(tmpy);               ss(nv) = ss(nv) + (ly-1)*std(tmpy)^2;               ns(nv) = ns(nv) + (ly-1);            end         end         if nn == n(nv) & length(tmpy) ~= 1            ly = length(tmpy);            ss(nv) = ss(nv) + (ly-1)*std(tmpy)^2;            ns(nv) = ns(nv) + (ly-1);         end         if xx(nn-1,nv) ~= xx(nn,nv)            tmpy = yy(nn,nv);         end          end      % Estimating variance for each dependent variable      if ns(nv) == 0         s2(nv) = 1;      else         s2(nv) = ss(nv) / ns(nv);      end   end   w = sum(n)./s2 / sum(n./s2);  % Vector of weightselse   w = 1;endmaxiterw = 20;                % Maximum number of iterations on weightsiterw = 0;w0 = w + 2*tolw;maxiterb = 100;               % Maximum number of iterations on parametersb = b0;unit = eye(k);                % Unit matrixxmax = max(max(x));% Start of iteration on weightswhile max(abs(w-w0)) > tolw & iterw < maxiterw   iterw = iterw + 1;   w0 = w;   iterb = 0;   delb = 2*tolb;   lambda = 1000;                % Initial value for lambda      % Calculating initial sum of squared residuals   for m = 1:p      yc(1:n(m),m) = feval(fnctn,x(1:n(m),m),b,varargin{:});   end   if v > p      [xx,yy] = ode23(ODEfile,[x0 xmax],y0,[],b,varargin{:});      for m = p+1:v         yc(1:n(m),m) = spline(xx,yy(:,m),x(1:n(m),m));      end   end      e = y - yc;                   % Residuals   for m = 1:v      % Sum of squared residuals for each dependent variable      ssr(m) = e(1:n(m),m)'*e(1:n(m),m);   end   phi = sum(w.*ssr);            % Weighted sum of squared residuals   deltaphi = 2*tolphi;   if trace      if v > 1         fprintf('\n\n Iteration on weights = %3d',iterw)         disp(' '), disp(headerw)         for m = 1:v            fprintf('    %2d      %10.4e\n',m,w(m))         end      end      fprintf('\n\n Starting values\n')      disp(headerb)      for m = 1:k         fprintf('    %3d      %10.4e\n',m,b(m))      end      fprintf(' Sum of squares = %10.4e\n',phi)      if method == 1         fprintf(' Lambda = %10.4e\n',lambda)      end   end      % Start of iteration on parameters   while max(abs(delb))>tolb & abs(deltaphi)>tolphi & iterb<maxiterb      iterb = iterb + 1;      b0 = b;      yc0 = yc;      phi0 = phi;      % Building the Jacobian matrix      for mk = 1:k         % Set db for derivation         if b(mk) ~= 0            db = abs(b(mk)) / 100;         else            db = 1 / 100;         end         b(mk) = b(mk) + db;         for mp = 1:p            yp = feval(fnctn,x(1:n(mp),mp),b,varargin{:});            jacob(1:n(mp),mk,mp) = (yp - yc(1:n(mp),mp)) / db;         end         if v > p            [xx,yy] = ode23(ODEfile,[x0 xmax],y0,[],b,varargin{:});            for mq = p+1:v               yp = spline(xx,yy(:,mq),x(1:n(mq),mq));               jacob(1:n(mq),mk,mq) = (yp - yc(1:n(mq),mq)) / db;            end         end         b(mk) = b(mk) - db;      end      % Calculation of the correction to parameters      A = zeros(k);      B = zeros(k,1);      for m = 1:v         J = jacob(1:n(m),:,m);         A = A + w(m) * J' * J;         B = B + w(m) * J' * (y(1:n(m),m) - yc(1:n(m),m));      end      switch method      case 1                               % Marquardt method         deltab = inv(A + lambda*unit) * B;      case 2                               % Gauss-Newton method         deltab = inv(A) * B;      end      b = b0 + deltab;                     % New vector of parameters            % Calculating new sum of squared residuals      for m = 1:p         yc(1:n(m),m) = feval(fnctn,x(1:n(m),m),b,varargin{:});      end      if v > p         [xx,yy] = ode23(ODEfile,[x0 xmax],y0,[],b,varargin{:});         for m = p+1:v            yc(1:n(m),m) = spline(xx,yy(:,m),x(1:n(m),m));         end      end      e = y - yc;                          % Residuals      for m = 1:v         % Sum of squared residuals of each dependent variable         ssr(m) = e(1:n(m),m)'*e(1:n(m),m);      end      phi = sum(w.*ssr);                   % Weighted sum of squared residuals            % Relative increment of parameters      for nk = 1:k         if b(nk) ~= 0            delb(nk) = (b(nk) - b0(nk)) / b(nk);         else            delb(nk) = (b(nk) - b0(nk));         end      end      % Adjusting lambda      deltaphi = phi - phi0;      if method ~= 2         if deltaphi < 0            lambda = lambda/4;         else            lambda = lambda*2;            b = b0;            yc = yc0;            phi = phi0;            delb = 2*tolb;         end      end      if trace         fprintf('\n Iteration on parameters = %3d\n',iterb)         disp(headerb)         for m = 1:k            fprintf('    %3d      %10.4e\n',m,b(m))         end         fprintf(' Sum of squares = %10.4e\n',phi)         if method == 1            fprintf(' Lambda = %10.4e\n',lambda)         end      end   end                                  % Iteration on parameters   s2 = ssr./(n-k/v);                   % New variances   w = sum(n)./s2 / sum(n./s2);         % New weights      if iterb >= maxiterb      warning('Warning : Maximum iterations on parameters reached.')   endend                                  	% Iteration on weightsif iterw >= maxiterw   warning('Warning : Maximum iterations on weights reached.')end 